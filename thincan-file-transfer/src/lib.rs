//! File-transfer protocol helpers for `thincan`.
//!
//! This crate provides Cap'n Proto message types and helpers for building a simple file transfer
//! protocol on top of `thincan`.
//!
//! ## Integration steps (embassy-style, no-alloc)
//! 1. Define the messages in your bus atlas (usually in your firmware/app crate):
//!    - `FileReq` / `FileChunk` / `FileAck` using the Cap'n Proto owned types from
//!      [`schema`].
//! 2. Implement [`Atlas`] for your generated marker type `your_atlas::Atlas`.
//! 3. Create two bounded channels:
//!    - an inbound queue for `FileReq`/`FileChunk` events, and
//!    - an outbound queue for `FileAck` responses to send.
//! 4. Integrate with `thincan` using either:
//!    - [`ReceiverIngress`] from a non-async context (e.g. `DispatchEventMeta` callback), or
//!    - a `thincan` bundle handler generated by [`file_transfer_bundle!`], which can `await`
//!      on queue send for backpressure.
//! 5. In a separate async task, call [`ReceiverNoAlloc::process_one`] to perform storage I/O and
//!    emit acks after writes complete (this provides natural backpressure).
//!
//! ### Sketch (enable `--features embassy`)
//! ```rust,ignore
//! use thincan_file_transfer as ft;
//! use embassy_sync::blocking_mutex::raw::NoopRawMutex;
//! use embassy_sync::channel::Channel;
//!
//! // Your bus atlas defines FileReq/FileChunk/FileAck message IDs (capnp types from `ft::schema`).
//! // `ReplyTo` is the addressing type provided by your ISO-TP demux (for UDS, typically `u8`).
//! type ReplyTo = u8;
//! const MAX_METADATA: usize = 64;
//! const MAX_CHUNK: usize = 1024;
//! const IN_DEPTH: usize = 8;
//! const ACK_DEPTH: usize = 8;
//!
//! static INBOUND: ft::InboundQueue<NoopRawMutex, ReplyTo, MAX_METADATA, MAX_CHUNK, IN_DEPTH> =
//!     Channel::new();
//! static OUTBOUND_ACKS: ft::OutboundAckQueue<NoopRawMutex, ReplyTo, ACK_DEPTH> = Channel::new();
//!
//! // Receive loop: enqueue file-transfer messages (no storage I/O here).
//! let ingestor = ft::ReceiverIngress::<MyAtlas, NoopRawMutex, ReplyTo, MAX_METADATA, MAX_CHUNK, IN_DEPTH>::new(&INBOUND);
//! # let reply_to: ReplyTo = 0;
//! # let payload: &[u8] = &[];
//! if let Ok(raw) = thincan::decode_wire(payload) {
//!     let _handled = ingestor.try_ingest_thincan_raw(reply_to, raw);
//! }
//!
//! // Alternative: define a `thincan` bundle so file-transfer messages are routed via `thincan`
//! // dispatch and can `await` on inbound queue send for backpressure:
//! //
//! // ft::file_transfer_bundle! { pub mod file_transfer(atlas) {} }
//! // thincan::bus_maplet! { pub mod maplet: atlas { reply_to: ReplyTo; bundles [file_transfer]; parser: thincan::DefaultParser; use msgs [FileReq, FileChunk, FileAck]; handles {} unhandled_by_default = true; ignore []; } }
//! // let mut handlers = maplet::HandlersImpl { app: MyApp, file_transfer: file_transfer::ReceiverIngressHandlers::new(&INBOUND) };
//! 
//! // Worker task: do async storage I/O and emit acks after writes complete.
//! let mut rx = ft::ReceiverNoAlloc::<MyAtlas, MyStore, NoopRawMutex, ReplyTo, MAX_METADATA, 32, MAX_CHUNK, IN_DEPTH, ACK_DEPTH>::new(
//!     MyStore::new(),
//!     &INBOUND,
//!     &OUTBOUND_ACKS,
//! );
//! loop {
//!     rx.process_one().await?;
//! }
//! ```
//!
//! ## Backpressure / throttling
//! This crate is designed so that **slow storage naturally throttles the transfer**:
//! - [`ReceiverNoAlloc::process_one`] only emits an [`AckToSend`] after the corresponding
//!   [`AsyncFileStore::write_at`] has completed.
//! - The sender side is expected to be **ack-driven** and only send a bounded "window" of chunks
//!   ahead of the most recent cumulative ack.
//!
//! The `tokio` feature includes [`AsyncSender`], which implements this "windowed, ack-driven"
//! behavior.
//!
//! ## Sending acks back (embassy-style)
//! [`ReceiverNoAlloc`] does not transmit on the bus. It pushes `AckToSend<ReplyTo>` items into your
//! outbound ack queue, and your application is responsible for encoding and sending those acks
//! to the correct `reply_to` address.
//!
//! With `--features heapless` you can encode Cap'n Proto bodies without allocation:
//! ```rust,ignore
//! # use thincan_file_transfer as ft;
//! # let mut scratch = ft::CapnpScratch::<8>::new();
//! # let mut out = [0u8; ft::file_ack_max_encoded_len()];
//! # let ack: ft::AckToSend<u8> = todo!();
//! let used = ft::encode_file_ack_into(
//!     &mut scratch,
//!     ack.ack.transfer_id,
//!     ack.ack.kind,
//!     ack.ack.next_offset,
//!     ack.ack.chunk_size,
//!     ack.ack.error,
//!     &mut out,
//! )?;
//! // Send `&out[..used]` as the body of your bus's `FileAck` message to `ack.reply_to`.
//! # Ok::<(), thincan::Error>(())
//! ```
//!
//! This crate is async-first and is designed for runtimes like embassy where storage I/O must not
//! block the executor.
#![cfg_attr(not(feature = "std"), no_std)]
#![allow(async_fn_in_trait)]

#[cfg(not(any(feature = "alloc", feature = "heapless")))]
compile_error!(
    "thincan-file-transfer requires either `alloc` (or `std`) or `heapless` (for no-alloc)."
);

#[cfg(feature = "alloc")]
extern crate alloc;

/// Re-exported for use by macros (`file_transfer_bundle!`) without requiring downstream crates to
/// depend on `capnp` directly.
#[doc(hidden)]
pub use capnp;

/// Re-exported for use by macros (`file_transfer_bundle!`) without requiring downstream crates to
/// depend on `embassy-sync` directly.
#[cfg(feature = "embassy")]
#[doc(hidden)]
pub use embassy_sync;

use core::marker::PhantomData;

capnp::generated_code!(pub mod file_transfer_capnp);
pub use file_transfer_capnp as schema;

/// Default chunk size (bytes) used by senders.
pub const DEFAULT_CHUNK_SIZE: usize = 64;

/// Cap'n Proto "word padding" (Cap'n Proto Data blobs are padded to a word boundary).
pub const fn capnp_padded_len(len: usize) -> usize {
    (len + 7) & !7
}

/// Upper bound for an encoded `FileReq` body (bytes) without metadata.
pub const fn file_req_max_encoded_len() -> usize {
    32
}

/// Upper bound for an encoded `FileReq` body (bytes) with metadata.
pub const fn file_offer_max_encoded_len(metadata_len: usize) -> usize {
    32 + capnp_padded_len(metadata_len)
}

/// Upper bound for an encoded `FileChunk` body (bytes).
pub const fn file_chunk_max_encoded_len(data_len: usize) -> usize {
    32 + capnp_padded_len(data_len)
}

/// Upper bound for an encoded `FileAck` body (bytes).
pub const fn file_ack_max_encoded_len() -> usize {
    24
}

/// Convert a byte count to a conservative Cap'n Proto scratch requirement (words).
pub const fn capnp_scratch_words_for_bytes(bytes: usize) -> usize {
    (bytes + 7) / 8
}

/// Receiver-side configuration.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct ReceiverConfig {
    /// Maximum accepted `FileChunk.data` length (bytes).
    ///
    /// - `0` means "no limit / accept any size" (back-compat default).
    /// - Non-zero values cause oversize chunks to be rejected as a protocol error.
    pub max_chunk_size: u32,
}

impl Default for ReceiverConfig {
    fn default() -> Self {
        Self { max_chunk_size: 0 }
    }
}

/// Atlas contract for file-transfer message types.
pub trait Atlas {
    type FileReq: thincan::Message;
    type FileChunk: thincan::Message;
    type FileAck: thincan::Message;
}

/// Async dependency required by the file-transfer bundle: a byte-addressable file store.
///
/// This is intended for async runtimes such as embassy, where storage I/O (flash, SD, etc.) should
/// not block the entire executor.
pub trait AsyncFileStore {
    type Error;
    type WriteHandle;

    async fn begin_write(
        &mut self,
        transfer_id: u32,
        total_len: u32,
    ) -> Result<Self::WriteHandle, Self::Error>;

    async fn write_at(
        &mut self,
        handle: &mut Self::WriteHandle,
        offset: u32,
        bytes: &[u8],
    ) -> Result<(), Self::Error>;

    async fn commit(&mut self, handle: Self::WriteHandle) -> Result<(), Self::Error>;

    async fn abort(&mut self, handle: Self::WriteHandle);
}

/// Errors produced by the file-transfer state machine.
#[derive(Debug)]
pub enum Error<E> {
    Store(E),
    Protocol,
    Capnp(capnp::Error),
}

/// Ack message that the receiver side would like to emit.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct PendingAck {
    pub transfer_id: u32,
    pub kind: schema::FileAckKind,
    pub next_offset: u32,
    pub chunk_size: u32,
    pub error: schema::FileAckError,
}

/// Value type used to encode a `FileReq` message for a specific atlas marker type `A`.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct FileReqValue<A> {
    pub transfer_id: u32,
    pub total_len: u32,
    _atlas: PhantomData<A>,
}

/// Value type used to encode a `FileReq` message including metadata and chunk negotiation.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct FileOfferValue<'a, A> {
    pub transfer_id: u32,
    pub total_len: u32,
    pub file_metadata: &'a [u8],
    pub sender_max_chunk_size: u32,
    _atlas: PhantomData<A>,
}

/// Value type used to encode a `FileChunk` message for a specific atlas marker type `A`.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct FileChunkValue<'a, A> {
    pub transfer_id: u32,
    pub offset: u32,
    pub data: &'a [u8],
    _atlas: PhantomData<A>,
}

impl<A> FileReqValue<A> {
    /// Construct a `FileReq` value.
    pub fn new(transfer_id: u32, total_len: u32) -> Self {
        Self {
            transfer_id,
            total_len,
            _atlas: PhantomData,
        }
    }
}

/// Convenience constructor for [`FileReqValue`].
pub fn file_req<A>(transfer_id: u32, total_len: u32) -> FileReqValue<A> {
    FileReqValue::new(transfer_id, total_len)
}

impl<'a, A> FileOfferValue<'a, A> {
    /// Construct a `FileReq` offer value.
    pub fn new(
        transfer_id: u32,
        total_len: u32,
        sender_max_chunk_size: u32,
        file_metadata: &'a [u8],
    ) -> Self {
        Self {
            transfer_id,
            total_len,
            file_metadata,
            sender_max_chunk_size,
            _atlas: PhantomData,
        }
    }
}

/// Convenience constructor for [`FileOfferValue`].
pub fn file_offer<'a, A>(
    transfer_id: u32,
    total_len: u32,
    sender_max_chunk_size: u32,
    file_metadata: &'a [u8],
) -> FileOfferValue<'a, A> {
    FileOfferValue::new(transfer_id, total_len, sender_max_chunk_size, file_metadata)
}

impl<'a, A> FileChunkValue<'a, A> {
    /// Construct a `FileChunk` value.
    pub fn new(transfer_id: u32, offset: u32, data: &'a [u8]) -> Self {
        Self {
            transfer_id,
            offset,
            data,
            _atlas: PhantomData,
        }
    }
}

/// Convenience constructor for [`FileChunkValue`].
pub fn file_chunk<'a, A>(transfer_id: u32, offset: u32, data: &'a [u8]) -> FileChunkValue<'a, A> {
    FileChunkValue::new(transfer_id, offset, data)
}

/// Value type used to encode a `FileAck` message.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct FileAckValue<A> {
    pub transfer_id: u32,
    pub kind: schema::FileAckKind,
    pub next_offset: u32,
    pub chunk_size: u32,
    pub error: schema::FileAckError,
    _atlas: PhantomData<A>,
}

impl<A> FileAckValue<A> {
    pub fn new(
        transfer_id: u32,
        kind: schema::FileAckKind,
        next_offset: u32,
        chunk_size: u32,
        error: schema::FileAckError,
    ) -> Self {
        Self {
            transfer_id,
            kind,
            next_offset,
            chunk_size,
            error,
            _atlas: PhantomData,
        }
    }
}

pub fn file_ack_accept<A>(transfer_id: u32, chunk_size: u32) -> FileAckValue<A> {
    FileAckValue::new(
        transfer_id,
        schema::FileAckKind::Accept,
        0,
        chunk_size,
        schema::FileAckError::None,
    )
}

pub fn file_ack_progress<A>(transfer_id: u32, next_offset: u32) -> FileAckValue<A> {
    FileAckValue::new(
        transfer_id,
        schema::FileAckKind::Ack,
        next_offset,
        0,
        schema::FileAckError::None,
    )
}

pub fn file_ack_reject<A>(transfer_id: u32, error: schema::FileAckError) -> FileAckValue<A> {
    FileAckValue::new(transfer_id, schema::FileAckKind::Reject, 0, 0, error)
}

#[cfg(feature = "alloc")]
mod alloc_encode;

#[cfg(feature = "heapless")]
mod heapless_encode;
#[cfg(feature = "heapless")]
pub use heapless_encode::{
    CapnpScratch, decode_file_ack_fields, encode_file_ack_into, encode_file_chunk_into,
    encode_file_offer_into,
};

#[cfg(feature = "tokio")]
mod tokio_impl;
#[cfg(feature = "tokio")]
pub use tokio_impl::{
    Ack, AckInbox, AckStream, AsyncSendResult, AsyncSender, ack_channel, decode_file_ack,
};

#[cfg(feature = "embassy")]
mod embassy_receiver;
#[cfg(feature = "embassy")]
pub use embassy_receiver::{
    AckToSend, InboundEvent, InboundQueue, OutboundAckQueue, ReceiverIngress, ReceiverNoAlloc,
    ReceiverNoAllocConfig,
};

/// Define a `thincan` bundle for the standard file-transfer messages (`FileReq`, `FileChunk`,
/// `FileAck`) in your atlas.
///
/// This restores the ergonomic `thincan` integration where file-transfer messages are routed via
/// `thincan::bus_maplet!` like any other bundle.
///
/// The generated bundle expects your atlas module to define:
/// - `FileReq(capnp = thincan_file_transfer::schema::file_req::Owned)`
/// - `FileChunk(capnp = thincan_file_transfer::schema::file_chunk::Owned)`
/// - `FileAck(capnp = thincan_file_transfer::schema::file_ack::Owned)`
///
/// It also generates optional helper handler types:
/// - `ReceiverIngressHandlers` (requires `--features embassy`): enqueues requests/chunks into an
///   embassy channel using `send().await` for backpressure.
/// - `AckInboxHandlers` (requires `--features tokio`): decodes `FileAck` and pushes into
///   [`AckInbox`].
#[macro_export]
macro_rules! file_transfer_bundle {
    ($vis:vis mod $bundle:ident ($atlas:ident) $( { $($tt:tt)* } )? ) => {
        ::thincan::bundle! {
            $vis mod $bundle($atlas) {
                parser: ::thincan::DefaultParser;
                use msgs [FileReq, FileChunk, FileAck];
                handles {
                    FileReq => on_file_req,
                    FileChunk => on_file_chunk,
                    FileAck => on_file_ack,
                }
                items {
                    #[cfg(feature = "embassy")]
                    #[derive(Clone, Copy)]
                    pub struct ReceiverIngressHandlers<
                        'q,
                        M,
                        ReplyTo,
                        const MAX_METADATA: usize,
                        const MAX_CHUNK: usize,
                        const DEPTH: usize,
                    >
                    where
                        M: $crate::embassy_sync::blocking_mutex::raw::RawMutex,
                        ReplyTo: Copy,
                    {
                        inbound: &'q $crate::InboundQueue<M, ReplyTo, MAX_METADATA, MAX_CHUNK, DEPTH>,
                    }

                    #[cfg(feature = "embassy")]
                    impl<
                        'q,
                        M,
                        ReplyTo,
                        const MAX_METADATA: usize,
                        const MAX_CHUNK: usize,
                        const DEPTH: usize,
                    > ReceiverIngressHandlers<'q, M, ReplyTo, MAX_METADATA, MAX_CHUNK, DEPTH>
                    where
                        M: $crate::embassy_sync::blocking_mutex::raw::RawMutex,
                        ReplyTo: Copy,
                    {
                        pub fn new(
                            inbound: &'q $crate::InboundQueue<
                                M,
                                ReplyTo,
                                MAX_METADATA,
                                MAX_CHUNK,
                                DEPTH,
                            >,
                        ) -> Self {
                            Self { inbound }
                        }
                    }

                    #[cfg(feature = "embassy")]
                    impl<
                        'a,
                        'q,
                        M,
                        ReplyTo,
                        const MAX_METADATA: usize,
                        const MAX_CHUNK: usize,
                        const DEPTH: usize,
                    > Handlers<'a, ReplyTo> for ReceiverIngressHandlers<'q, M, ReplyTo, MAX_METADATA, MAX_CHUNK, DEPTH>
                    where
                        M: $crate::embassy_sync::blocking_mutex::raw::RawMutex,
                        ReplyTo: Copy,
                    {
                        type Error = core::convert::Infallible;

                        async fn on_file_req(
                            &mut self,
                            meta: ::thincan::RecvMeta<ReplyTo>,
                            msg: ::thincan::CapnpTyped<'a, $crate::schema::file_req::Owned>,
                        ) -> Result<(), Self::Error> {
                            use core::cmp::min;
                            let mut metadata = [0u8; MAX_METADATA];

                            let parsed = msg.with_root($crate::capnp::message::ReaderOptions::default(), |root| {
                                let transfer_id = root.get_transfer_id();
                                let total_len = root.get_total_len();
                                let sender_max_chunk_size = root.get_sender_max_chunk_size();
                                let meta = root.get_file_metadata().unwrap_or(&[]);
                                let overflow = meta.len() > MAX_METADATA;
                                let copy_len = min(meta.len(), MAX_METADATA);
                                metadata[..copy_len].copy_from_slice(&meta[..copy_len]);
                                (transfer_id, total_len, sender_max_chunk_size, meta.len(), overflow)
                            });

                            let (transfer_id, total_len, sender_max_chunk_size, meta_len, overflow) =
                                parsed.unwrap_or((0, 0, 0, 0, true));

                            let ev = $crate::InboundEvent::FileReq {
                                reply_to: meta.reply_to,
                                transfer_id,
                                total_len,
                                sender_max_chunk_size,
                                metadata_len: (min(meta_len, u16::MAX as usize) as u16),
                                metadata,
                                metadata_overflow: overflow,
                            };
                            self.inbound.send(ev).await;
                            Ok(())
                        }

                        async fn on_file_chunk(
                            &mut self,
                            meta: ::thincan::RecvMeta<ReplyTo>,
                            msg: ::thincan::CapnpTyped<'a, $crate::schema::file_chunk::Owned>,
                        ) -> Result<(), Self::Error> {
                            use core::cmp::min;
                            let mut data = [0u8; MAX_CHUNK];

                            let parsed = msg.with_root($crate::capnp::message::ReaderOptions::default(), |root| {
                                let transfer_id = root.get_transfer_id();
                                let offset = root.get_offset();
                                let d = root.get_data().unwrap_or(&[]);
                                let overflow = d.len() > MAX_CHUNK;
                                let copy_len = min(d.len(), MAX_CHUNK);
                                data[..copy_len].copy_from_slice(&d[..copy_len]);
                                (transfer_id, offset, d.len(), overflow)
                            });

                            let (transfer_id, offset, data_len, overflow) =
                                parsed.unwrap_or((0, 0, 0, true));

                            let ev = $crate::InboundEvent::FileChunk {
                                reply_to: meta.reply_to,
                                transfer_id,
                                offset,
                                data_len: (min(data_len, u16::MAX as usize) as u16),
                                data,
                                data_overflow: overflow,
                            };
                            self.inbound.send(ev).await;
                            Ok(())
                        }

                        async fn on_file_ack(
                            &mut self,
                            _meta: ::thincan::RecvMeta<ReplyTo>,
                            _msg: ::thincan::CapnpTyped<'a, $crate::schema::file_ack::Owned>,
                        ) -> Result<(), Self::Error> {
                            Ok(())
                        }
                    }

                    #[cfg(feature = "tokio")]
                    #[derive(Debug, Clone)]
                    pub struct AckInboxHandlers {
                        inbox: $crate::AckInbox,
                    }

                    #[cfg(feature = "tokio")]
                    impl AckInboxHandlers {
                        pub fn new(inbox: $crate::AckInbox) -> Self {
                            Self { inbox }
                        }
                    }

                    #[cfg(feature = "tokio")]
                    impl<'a, ReplyTo> Handlers<'a, ReplyTo> for AckInboxHandlers
                    where
                        ReplyTo: Copy,
                    {
                        type Error = core::convert::Infallible;

                        async fn on_file_req(
                            &mut self,
                            _meta: ::thincan::RecvMeta<ReplyTo>,
                            _msg: ::thincan::CapnpTyped<'a, $crate::schema::file_req::Owned>,
                        ) -> Result<(), Self::Error> {
                            Ok(())
                        }

                        async fn on_file_chunk(
                            &mut self,
                            _meta: ::thincan::RecvMeta<ReplyTo>,
                            _msg: ::thincan::CapnpTyped<'a, $crate::schema::file_chunk::Owned>,
                        ) -> Result<(), Self::Error> {
                            Ok(())
                        }

                        async fn on_file_ack(
                            &mut self,
                            _meta: ::thincan::RecvMeta<ReplyTo>,
                            msg: ::thincan::CapnpTyped<'a, $crate::schema::file_ack::Owned>,
                        ) -> Result<(), Self::Error> {
                            if let Ok(ack) = $crate::decode_file_ack(msg) {
                                self.inbox.push(ack);
                            }
                            Ok(())
                        }
                    }

                    #[cfg(all(feature = "embassy", feature = "tokio"))]
                    #[derive(Clone)]
                    pub struct CombinedHandlers<
                        'q,
                        M,
                        ReplyTo,
                        const MAX_METADATA: usize,
                        const MAX_CHUNK: usize,
                        const DEPTH: usize,
                    >
                    where
                        M: $crate::embassy_sync::blocking_mutex::raw::RawMutex,
                        ReplyTo: Copy,
                    {
                        pub ingress: ReceiverIngressHandlers<'q, M, ReplyTo, MAX_METADATA, MAX_CHUNK, DEPTH>,
                        pub inbox: AckInboxHandlers,
                    }

                    #[cfg(all(feature = "embassy", feature = "tokio"))]
                    impl<
                        'a,
                        'q,
                        M,
                        ReplyTo,
                        const MAX_METADATA: usize,
                        const MAX_CHUNK: usize,
                        const DEPTH: usize,
                    > Handlers<'a, ReplyTo> for CombinedHandlers<'q, M, ReplyTo, MAX_METADATA, MAX_CHUNK, DEPTH>
                    where
                        M: $crate::embassy_sync::blocking_mutex::raw::RawMutex,
                        ReplyTo: Copy,
                    {
                        type Error = core::convert::Infallible;

                        async fn on_file_req(
                            &mut self,
                            meta: ::thincan::RecvMeta<ReplyTo>,
                            msg: ::thincan::CapnpTyped<'a, $crate::schema::file_req::Owned>,
                        ) -> Result<(), Self::Error> {
                            self.ingress.on_file_req(meta, msg).await
                        }

                        async fn on_file_chunk(
                            &mut self,
                            meta: ::thincan::RecvMeta<ReplyTo>,
                            msg: ::thincan::CapnpTyped<'a, $crate::schema::file_chunk::Owned>,
                        ) -> Result<(), Self::Error> {
                            self.ingress.on_file_chunk(meta, msg).await
                        }

                        async fn on_file_ack(
                            &mut self,
                            meta: ::thincan::RecvMeta<ReplyTo>,
                            msg: ::thincan::CapnpTyped<'a, $crate::schema::file_ack::Owned>,
                        ) -> Result<(), Self::Error> {
                            self.inbox.on_file_ack(meta, msg).await
                        }
                    }
                }
            }
        }
    };
}
